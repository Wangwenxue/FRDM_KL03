###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        29/Feb/2016  22:11:43
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\b51443\Desktop\FRDM_KL03Z\kl03-frdm-demo\src\drivers\smc\smc.c
#    Command line =  
#        C:\Users\b51443\Desktop\FRDM_KL03Z\kl03-frdm-demo\src\drivers\smc\smc.c
#        -D IAR -D FREEDOM -lCN
#        C:\Users\b51443\Desktop\FRDM_KL03Z\kl03-frdm-demo\build\iar\PWM\FLASH_32KB\List\
#        -o
#        C:\Users\b51443\Desktop\FRDM_KL03Z\kl03-frdm-demo\build\iar\PWM\FLASH_32KB\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\b51443\Desktop\FRDM_KL03Z\kl03-frdm-demo\build\iar\PWM\..\..\..\src\projects\PWM\
#        -I
#        C:\Users\b51443\Desktop\FRDM_KL03Z\kl03-frdm-demo\build\iar\PWM\..\..\..\src\common\
#        -I
#        C:\Users\b51443\Desktop\FRDM_KL03Z\kl03-frdm-demo\build\iar\PWM\..\..\..\src\cpu\
#        -I
#        C:\Users\b51443\Desktop\FRDM_KL03Z\kl03-frdm-demo\build\iar\PWM\..\..\..\src\cpu\headers\
#        -I
#        C:\Users\b51443\Desktop\FRDM_KL03Z\kl03-frdm-demo\build\iar\PWM\..\..\..\src\drivers\lptmr\
#        -I
#        C:\Users\b51443\Desktop\FRDM_KL03Z\kl03-frdm-demo\build\iar\PWM\..\..\..\src\drivers\mcg\
#        -I
#        C:\Users\b51443\Desktop\FRDM_KL03Z\kl03-frdm-demo\build\iar\PWM\..\..\..\src\drivers\pmc\
#        -I
#        C:\Users\b51443\Desktop\FRDM_KL03Z\kl03-frdm-demo\build\iar\PWM\..\..\..\src\drivers\rcm\
#        -I
#        C:\Users\b51443\Desktop\FRDM_KL03Z\kl03-frdm-demo\build\iar\PWM\..\..\..\src\drivers\smc\
#        -I
#        C:\Users\b51443\Desktop\FRDM_KL03Z\kl03-frdm-demo\build\iar\PWM\..\..\..\src\drivers\uart\
#        -I
#        C:\Users\b51443\Desktop\FRDM_KL03Z\kl03-frdm-demo\build\iar\PWM\..\..\..\src\drivers\wdog\
#        -I
#        C:\Users\b51443\Desktop\FRDM_KL03Z\kl03-frdm-demo\build\iar\PWM\..\..\..\src\drivers\cmp\
#        -I
#        C:\Users\b51443\Desktop\FRDM_KL03Z\kl03-frdm-demo\build\iar\PWM\..\..\..\src\platforms\
#        -I C:\Users\b51443\Desktop\FRDM_KL03Z\kl03-frdm-demo\build\iar\PWM\..\
#        -I
#        C:\Users\b51443\Desktop\FRDM_KL03Z\kl03-frdm-demo\build\iar\PWM\..\..\..\src\drivers\tpm\
#        -Ol --use_c++_inline
#    List file    =  
#        C:\Users\b51443\Desktop\FRDM_KL03Z\kl03-frdm-demo\build\iar\PWM\FLASH_32KB\List\smc.lst
#    Object file  =  
#        C:\Users\b51443\Desktop\FRDM_KL03Z\kl03-frdm-demo\build\iar\PWM\FLASH_32KB\Obj\smc.o
#
###############################################################################

C:\Users\b51443\Desktop\FRDM_KL03Z\kl03-frdm-demo\src\drivers\smc\smc.c
      1          /*
      2           * File:        smc.c
      3           * Purpose:     Provides routines for entering low power modes.
      4           *
      5           * Notes:	Since the wakeup mechanism for low power modes
      6           *              will be application specific, these routines
      7           *              do not include code to setup interrupts to exit
      8           *              from the low power modes. The desired means of
      9           *              low power mode exit should be configured before
     10           *              calling any of these functions.
     11           *
     12           *              These routines do not include protection to
     13           *              prevent illegal state transitions in the mode
     14           *              controller, and all routines that write to the
     15           *              PMPROT register write a value to allow all
     16           *              possible low power modes (it is write once, so
     17           *              if only the currently requested mode is enabled
     18           *              a different mode couldn't be enabled later on).
     19           *              
     20           */
     21          
     22          #include "common.h"
     23          #include "smc.h"
     24          
     25          /***************************************************************/
     26          /*
     27           * Configures the ARM system control register for WAIT(sleep)mode
     28           * and then executes the WFI instruction to enter the mode.
     29           *
     30           * Parameters:
     31           * none
     32           *
     33           */
     34          

   \                                 In section .text, align 4, keep-with-next
     35          void sleep (void)
     36          {
     37          /* Clear the SLEEPDEEP bit to make sure we go into WAIT (sleep) 
     38           * mode instead of deep sleep.
     39           */
     40          SCB_SCR &= ~SCB_SCR_SLEEPDEEP_MASK;
   \                     sleep: (+1)
   \   00000000   0x....             LDR      R0,??DataTable10  ;; 0xe000ed10
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2104             MOVS     R1,#+4
   \   00000006   0x4388             BICS     R0,R0,R1
   \   00000008   0x....             LDR      R1,??DataTable10  ;; 0xe000ed10
   \   0000000A   0x6008             STR      R0,[R1, #+0]
     41          
     42          #ifdef CMSIS
     43            __wfi();
     44          #else
     45            /* WFI instruction will start entry into WAIT mode */
     46            asm("WFI");
   \   0000000C   0xBF30             WFI
     47          #endif 
     48          }
   \   0000000E   0x4770             BX       LR               ;; return
     49          /***************************************************************/
     50          /*
     51           * Configures the ARM system control register for STOP  
     52           * (deepsleep) mode and then executes the WFI instruction 
     53           * to enter the mode.
     54           *
     55           * Parameters:
     56           * none
     57           *
     58           */
     59          

   \                                 In section .text, align 4, keep-with-next
     60          void deepsleep (void)
     61          {
     62            /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
     63            SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
   \                     deepsleep: (+1)
   \   00000000   0x....             LDR      R0,??DataTable10  ;; 0xe000ed10
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2104             MOVS     R1,#+4
   \   00000006   0x4301             ORRS     R1,R1,R0
   \   00000008   0x....             LDR      R0,??DataTable10  ;; 0xe000ed10
   \   0000000A   0x6001             STR      R1,[R0, #+0]
     64          
     65          #ifdef CMSIS
     66            __wfi();
     67          #else
     68            /* WFI instruction will start entry into STOP mode */
     69            asm("WFI");
   \   0000000C   0xBF30             WFI
     70          #endif
     71          }
   \   0000000E   0x4770             BX       LR               ;; return
     72          /********************************************************************/
     73          /* WAIT mode entry routine. Puts the processor into wait mode.
     74           * In this mode the core clock is disabled (no code executing), but 
     75           * bus clocks are enabled (peripheral modules are operational). 
     76           *
     77           * Mode transitions:
     78           * RUN -> WAIT
     79           * VLPR -> VLPW
     80           *
     81           * This function can be used to enter normal wait mode or VLPW
     82           * mode. If you are executing in normal run mode when calling this
     83           * function, then you will enter normal wait mode. If you are in VLPR
     84           * mode when calling this function, then you will enter VLPW mode instead.
     85           *
     86           * NOTE: Some modules include a programmable option to disable them in 
     87           * wait mode. If those modules are programmed to disable in wait mode, 
     88           * they will not be able to generate interrupts to wake up the core.
     89           *
     90           * WAIT mode is exited using any enabled interrupt or RESET, so no
     91           * exit_wait routine is needed. 
     92           * 
     93           * 
     94           * Parameters:
     95           * none
     96           */

   \                                 In section .text, align 2, keep-with-next
     97          void enter_wait(void)
     98          {
   \                     enter_wait: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     99          #ifdef CMSIS
    100              /* Clear the SLEEPDEEP bit to make sure we go into WAIT (sleep) mode instead
    101               * of deep sleep.
    102               */
    103          	SCB_SCR &= ~SCB_SCR_SLEEPDEEP_MASK;
    104                  
    105              __wfi();
    106          #else
    107              wait();
   \   00000002   0x.... 0x....      BL       wait
    108          #endif
    109          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    110          /********************************************************************/
    111          /* STOP mode entry routine. Puts the processor into normal stop mode.
    112           * In this mode core, bus and peripheral clocks are disabled.
    113           *
    114           * Mode transitions:
    115           * RUN -> STOP
    116           *
    117           * This function can be used to enter normal stop mode. 
    118           * If you are executing in normal run mode when calling this
    119           * function and AVLP = 0, then you will enter normal stop mode. 
    120           * If AVLP = 1 with previous write to PMPROT
    121           * then you will enter VLPS mode instead.
    122           *
    123           * STOP mode is exited using any enabled interrupt or RESET, so no
    124           * exit_stop routine is needed.
    125           *
    126           * Parameters:
    127           * Partial Stop Option:  
    128           *  0x00 = STOP - Normal Stop Mode
    129           *  0x40 = PSTOP1 - Partial Stop with both system and bus clocks disabled
    130           *  0x80 = PSTOP2 - Partial Stop with system clock disabled and bus clock enabled
    131           *  0xC0 = Reserved
    132           */

   \                                 In section .text, align 2, keep-with-next
    133          void enter_stop(unsigned char partial_stop_opt)
    134          {
   \                     enter_stop: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    135            /* The PMPROT register may have already been written by init code
    136               If so then this next write is not done since  
    137               PMPROT is write once after RESET  
    138               this write-once bit allows the MCU to enter the
    139               normal STOP mode.
    140               If AVLP is already a 1, VLPS mode is entered instead of normal STOP*/
    141            SMC_PMPROT = 0;  
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x....             LDR      R2,??DataTable9  ;; 0x4007e000
   \   00000006   0x7011             STRB     R1,[R2, #+0]
    142          
    143            /* Set the STOPM field to 0b000 for normal STOP mode */
    144            SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK;
   \   00000008   0x....             LDR      R1,??DataTable10_1  ;; 0x4007e001
   \   0000000A   0x7809             LDRB     R1,[R1, #+0]
   \   0000000C   0x22F8             MOVS     R2,#+248
   \   0000000E   0x400A             ANDS     R2,R2,R1
   \   00000010   0x....             LDR      R1,??DataTable10_1  ;; 0x4007e001
   \   00000012   0x700A             STRB     R2,[R1, #+0]
    145            SMC_PMCTRL |=  SMC_PMCTRL_STOPM(0); 
   \   00000014   0x....             LDR      R1,??DataTable10_1  ;; 0x4007e001
   \   00000016   0x7809             LDRB     R1,[R1, #+0]
   \   00000018   0x....             LDR      R2,??DataTable10_1  ;; 0x4007e001
   \   0000001A   0x7011             STRB     R1,[R2, #+0]
    146            SMC_STOPCTRL &= ~SMC_STOPCTRL_PSTOPO_MASK;
   \   0000001C   0x....             LDR      R1,??DataTable9_1  ;; 0x4007e002
   \   0000001E   0x7809             LDRB     R1,[R1, #+0]
   \   00000020   0x0689             LSLS     R1,R1,#+26       ;; ZeroExtS R1,R1,#+26,#+26
   \   00000022   0x0E89             LSRS     R1,R1,#+26
   \   00000024   0x....             LDR      R2,??DataTable9_1  ;; 0x4007e002
   \   00000026   0x7011             STRB     R1,[R2, #+0]
    147            SMC_STOPCTRL |= partial_stop_opt;
   \   00000028   0x....             LDR      R1,??DataTable9_1  ;; 0x4007e002
   \   0000002A   0x7809             LDRB     R1,[R1, #+0]
   \   0000002C   0x4308             ORRS     R0,R0,R1
   \   0000002E   0x....             LDR      R1,??DataTable9_1  ;; 0x4007e002
   \   00000030   0x7008             STRB     R0,[R1, #+0]
    148            /*wait for write to complete to SMC before stopping core */  
    149            partial_stop_opt = SMC_PMCTRL;
   \   00000032   0x....             LDR      R0,??DataTable10_1  ;; 0x4007e001
   \   00000034   0x7800             LDRB     R0,[R0, #+0]
    150            
    151          #ifdef CMSIS
    152            /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
    153            SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
    154            __wfi();
    155          #else
    156            stop();
   \   00000036   0x.... 0x....      BL       stop
    157          #endif
    158          }
   \   0000003A   0xBD01             POP      {R0,PC}          ;; return
    159          /****************************************************************/
    160          /* VLPR mode entry routine.Puts the processor into very low power
    161           * run mode. In this mode all clocks are enabled, but the core clock limited. 
    162           * The flash clock is limited to 1MHz or less. 
    163           *
    164           * Mode transitions:
    165           * RUN -> VLPR
    166           *
    167           * exit_vlpr() function can be used 
    168           * to switch from VLPR back to RUN. 
    169           * 
    170           * while in VLPR,VLPW or VLPS the exit to VLPR is not possible  
    171           *
    172           *
    173           * Parameters:
    174           * Return value : PMSTAT value or error code
    175           *                PMSTAT = return_value = PMSTAT
    176           *                         000_0001 Current power mode is RUN
    177           *                         000_0100 Current power mode is VLPR
    178           *                ERROR Code =  0x14 - already in VLPR mode
    179           *                           =  0x24 - REGONS never clear indicating stop regulation
    180           */

   \                                 In section .text, align 2, keep-with-next
    181          int enter_vlpr(void)
    182          {
   \                     enter_vlpr: (+1)
   \   00000000   0xB500             PUSH     {LR}
    183            int i; 
    184            unsigned int return_value;
    185            if ((SMC_PMSTAT & SMC_PMSTAT_PMSTAT_MASK)== 4){
   \   00000002   0x....             LDR      R1,??DataTable10_2  ;; 0x4007e003
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x0649             LSLS     R1,R1,#+25       ;; ZeroExtS R1,R1,#+25,#+25
   \   0000000A   0x0E49             LSRS     R1,R1,#+25
   \   0000000C   0x2904             CMP      R1,#+4
   \   0000000E   0xD100             BNE      ??enter_vlpr_0
    186                   return_value = 0x14;
   \   00000010   0x2014             MOVS     R0,#+20
    187                   }
    188            /* The PMPROT register may have already been written by init code
    189               If so then this next write is not done.  
    190               PMPROT is write once after RESET  
    191               this write-once bit allows the MCU to enter the
    192               very low power modes: VLPR, VLPW, and VLPS   */
    193            SMC_PMPROT = SMC_PMPROT_AVLP_MASK;  
   \                     ??enter_vlpr_0: (+1)
   \   00000012   0x2120             MOVS     R1,#+32
   \   00000014   0x....             LDR      R2,??DataTable9  ;; 0x4007e000
   \   00000016   0x7011             STRB     R1,[R2, #+0]
    194              
    195            /* Set the (for MC1)LPLLSM or (for MC2)STOPM field 
    196               to 0b010 for VLPS mode -
    197               and RUNM bits to 0b010 for VLPR mode  */
    198            SMC_PMCTRL &= ~SMC_PMCTRL_RUNM_MASK; 
   \   00000018   0x....             LDR      R1,??DataTable10_1  ;; 0x4007e001
   \   0000001A   0x7809             LDRB     R1,[R1, #+0]
   \   0000001C   0x229F             MOVS     R2,#+159
   \   0000001E   0x400A             ANDS     R2,R2,R1
   \   00000020   0x....             LDR      R1,??DataTable10_1  ;; 0x4007e001
   \   00000022   0x700A             STRB     R2,[R1, #+0]
    199            SMC_PMCTRL  |= SMC_PMCTRL_RUNM(0x2);
   \   00000024   0x....             LDR      R1,??DataTable10_1  ;; 0x4007e001
   \   00000026   0x7809             LDRB     R1,[R1, #+0]
   \   00000028   0x2240             MOVS     R2,#+64
   \   0000002A   0x430A             ORRS     R2,R2,R1
   \   0000002C   0x....             LDR      R1,??DataTable10_1  ;; 0x4007e001
   \   0000002E   0x700A             STRB     R2,[R1, #+0]
    200            /* Wait for VLPS regulator mode to be confirmed */
    201            for (i = 0 ; i < 10000 ; i++)
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0xE000             B        ??enter_vlpr_1
   \                     ??enter_vlpr_2: (+1)
   \   00000034   0x1C49             ADDS     R1,R1,#+1
   \                     ??enter_vlpr_1: (+1)
   \   00000036   0x....             LDR      R2,??DataTable10_3  ;; 0x2710
   \   00000038   0x4291             CMP      R1,R2
   \   0000003A   0xDA04             BGE      ??enter_vlpr_3
    202              {     /* check that the value of REGONS bit is not 0
    203                       once it is a zero we can stop checking */
    204                if ((PMC_REGSC & PMC_REGSC_REGONS_MASK) ==0x04){
   \   0000003C   0x....             LDR      R2,??DataTable10_4  ;; 0x4007d002
   \   0000003E   0x7812             LDRB     R2,[R2, #+0]
   \   00000040   0xB2D2             UXTB     R2,R2
   \   00000042   0x0752             LSLS     R2,R2,#+29
   \   00000044   0xD4F6             BMI      ??enter_vlpr_2
    205                 /* 0 Regulator is in stop regulation or in transition 
    206                      to/from it
    207                    1 MCU is in Run regulation mode */
    208                }  
    209                else  break;
    210              }  
    211            if ((PMC_REGSC & PMC_REGSC_REGONS_MASK) ==0x04) 
   \                     ??enter_vlpr_3: (+1)
   \   00000046   0x....             LDR      R1,??DataTable10_4  ;; 0x4007d002
   \   00000048   0x7809             LDRB     R1,[R1, #+0]
   \   0000004A   0xB2C9             UXTB     R1,R1
   \   0000004C   0x0749             LSLS     R1,R1,#+29
   \   0000004E   0xD500             BPL      ??enter_vlpr_4
    212              {  
    213                return_value = 0x24; 
   \   00000050   0x2024             MOVS     R0,#+36
    214              }
    215            /* SMC_PMSTAT register only exist in Mode Controller 2 MCU versions */
    216            if ((SMC_PMSTAT & SMC_PMSTAT_PMSTAT_MASK) == 4)  
   \                     ??enter_vlpr_4: (+1)
   \   00000052   0x....             LDR      R1,??DataTable10_2  ;; 0x4007e003
   \   00000054   0x7809             LDRB     R1,[R1, #+0]
   \   00000056   0xB2C9             UXTB     R1,R1
   \   00000058   0x0649             LSLS     R1,R1,#+25       ;; ZeroExtS R1,R1,#+25,#+25
   \   0000005A   0x0E49             LSRS     R1,R1,#+25
   \   0000005C   0x2904             CMP      R1,#+4
   \   0000005E   0xD102             BNE      ??enter_vlpr_5
    217              {
    218                return_value = SMC_PMSTAT;
   \   00000060   0x....             LDR      R0,??DataTable10_2  ;; 0x4007e003
   \   00000062   0x7800             LDRB     R0,[R0, #+0]
   \   00000064   0xB2C0             UXTB     R0,R0
    219              }
    220            return (return_value);
   \                     ??enter_vlpr_5: (+1)
   \   00000066   0xBD00             POP      {PC}             ;; return
    221          }
    222          /********************************************************************/
    223          /* VLPR mode exit routine. Puts the processor into normal run mode
    224           * from VLPR mode. You can transition from VLPR to normal run using
    225           * this function.
    226           *
    227           * Mode transitions:
    228           * VLPR -> RUN
    229           *
    230           * Parameters:
    231           * none
    232           */
    233           /********************************************************************/
    234          

   \                                 In section .text, align 2, keep-with-next
    235          void exit_vlpr(void)
    236          {
   \                     exit_vlpr: (+1)
   \   00000000   0xB500             PUSH     {LR}
    237              int i;
    238              /* check to make sure in VLPR before exiting    */
    239              if  ((SMC_PMSTAT & SMC_PMSTAT_PMSTAT_MASK)== 4) {
   \   00000002   0x....             LDR      R0,??DataTable10_2  ;; 0x4007e003
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0xB2C0             UXTB     R0,R0
   \   00000008   0x0640             LSLS     R0,R0,#+25       ;; ZeroExtS R0,R0,#+25,#+25
   \   0000000A   0x0E40             LSRS     R0,R0,#+25
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD113             BNE      ??exit_vlpr_0
    240                
    241                 /* Clear RUNM */
    242                 SMC_PMCTRL &= ~SMC_PMCTRL_RUNM_MASK;
   \   00000010   0x....             LDR      R0,??DataTable10_1  ;; 0x4007e001
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x219F             MOVS     R1,#+159
   \   00000016   0x4001             ANDS     R1,R1,R0
   \   00000018   0x....             LDR      R0,??DataTable10_1  ;; 0x4007e001
   \   0000001A   0x7001             STRB     R1,[R0, #+0]
    243                                
    244                 /* Wait for normal RUN regulation mode to be confirmed */                   
    245                 // 1 PMSTAT MCU is in RUN  mode
    246                 // 4 PMSTAT MCU is in VLPR mode
    247                 for (i=0;i<0xff;i++)
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE009             B        ??exit_vlpr_1
    248                 {
    249                     if ((SMC_PMSTAT & SMC_PMSTAT_PMSTAT_MASK)== 1)
   \                     ??exit_vlpr_2: (+1)
   \   00000020   0x....             LDR      R1,??DataTable10_2  ;; 0x4007e003
   \   00000022   0x7809             LDRB     R1,[R1, #+0]
   \   00000024   0xB2C9             UXTB     R1,R1
   \   00000026   0x0649             LSLS     R1,R1,#+25       ;; ZeroExtS R1,R1,#+25,#+25
   \   00000028   0x0E49             LSRS     R1,R1,#+25
   \   0000002A   0x2901             CMP      R1,#+1
   \   0000002C   0xD101             BNE      ??exit_vlpr_3
    250                       if ((PMC_REGSC & PMC_REGSC_REGONS_MASK) == 1)
   \   0000002E   0x....             LDR      R1,??DataTable10_4  ;; 0x4007d002
   \   00000030   0x7809             LDRB     R1,[R1, #+0]
    251              	        break;
    252                 }           
   \                     ??exit_vlpr_3: (+1)
   \   00000032   0x1C40             ADDS     R0,R0,#+1
   \                     ??exit_vlpr_1: (+1)
   \   00000034   0x28FF             CMP      R0,#+255
   \   00000036   0xDBF3             BLT      ??exit_vlpr_2
    253              }  //if in VLPR mode
    254               // else if not in VLPR ignore call
    255          }
   \                     ??exit_vlpr_0: (+1)
   \   00000038   0xBD00             POP      {PC}             ;; return
    256          /***************************************************************/
    257          /* VLPS mode entry routine. Puts the processor into VLPS mode 
    258           * directly from run or VLPR modes. 
    259           *
    260           * Mode transitions:
    261           * RUN  -> VLPS
    262           * VLPR -> VLPS
    263           *
    264           * Note, when VLPS is entered directly from RUN or VLPR mode, 
    265           * exit to VLPR is disabled by hardware and the system will
    266           * always exit back to RUN.
    267           *
    268           * Parameters:  
    269           * none
    270           */
    271           /****************************************************************/
    272          

   \                                 In section .text, align 2, keep-with-next
    273          void enter_vlps(void)
    274          {
   \                     enter_vlps: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    275            volatile unsigned int dummyread;
    276            /* The PMPROT register may have already been written by init code
    277               If so then this next write is not done since  
    278               PMPROT is write once after RESET 
    279               allows the MCU to enter the VLPR, VLPW, and VLPS modes.
    280               If AVLP is already writen to 0 
    281               Stop is entered instead of VLPS*/
    282            SMC_PMPROT = SMC_PMPROT_AVLP_MASK;           
   \   00000002   0x2020             MOVS     R0,#+32
   \   00000004   0x....             LDR      R1,??DataTable9  ;; 0x4007e000
   \   00000006   0x7008             STRB     R0,[R1, #+0]
    283            /* Set the STOPM field to 0b010 for VLPS mode */
    284            SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK; 
   \   00000008   0x....             LDR      R0,??DataTable10_1  ;; 0x4007e001
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x21F8             MOVS     R1,#+248
   \   0000000E   0x4001             ANDS     R1,R1,R0
   \   00000010   0x....             LDR      R0,??DataTable10_1  ;; 0x4007e001
   \   00000012   0x7001             STRB     R1,[R0, #+0]
    285            SMC_PMCTRL |=  SMC_PMCTRL_STOPM(0x2); 
   \   00000014   0x....             LDR      R0,??DataTable10_1  ;; 0x4007e001
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x2102             MOVS     R1,#+2
   \   0000001A   0x4301             ORRS     R1,R1,R0
   \   0000001C   0x....             LDR      R0,??DataTable10_1  ;; 0x4007e001
   \   0000001E   0x7001             STRB     R1,[R0, #+0]
    286            /*wait for write to complete to SMC before stopping core */  
    287            dummyread = SMC_PMCTRL;
   \   00000020   0x....             LDR      R0,??DataTable10_1  ;; 0x4007e001
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0xB2C0             UXTB     R0,R0
   \   00000026   0x9000             STR      R0,[SP, #+0]
    288            dummyread++;
   \   00000028   0x9800             LDR      R0,[SP, #+0]
   \   0000002A   0x1C40             ADDS     R0,R0,#+1
   \   0000002C   0x9000             STR      R0,[SP, #+0]
    289            /* Now execute the stop instruction to go into VLPS */
    290            #ifdef CMSIS
    291            /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
    292            SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
    293            __wfi();
    294          #else
    295            stop();
   \   0000002E   0x.... 0x....      BL       stop
    296          #endif
    297          }
   \   00000032   0xBD01             POP      {R0,PC}          ;; return
    298          /****************************************************************/
    299          /* LLS mode entry routine. Puts the processor into LLS mode from
    300           * normal run mode or VLPR. 
    301           *
    302           * Mode transitions:
    303           * RUN -> LLS
    304           * VLPR -> LLS
    305           *
    306           * NOTE: LLS mode will always exit to RUN mode even if you were 
    307           * in VLPR mode before entering LLS.
    308           *
    309           * Wakeup from LLS mode is controlled by the LLWU module. Most
    310           * modules cannot issue a wakeup interrupt in LLS mode, so make
    311           * sure to setup the desired wakeup sources in the LLWU before 
    312           * calling this function.
    313           *
    314           * Parameters:
    315           * none
    316           */
    317           /********************************************************************/
    318          
    319          
    320          /***** No LLS mode in KL02 ******/
    321          
    322          //void enter_lls(void)
    323          //{
    324          //   volatile unsigned int dummyread;
    325          //   /* Write to PMPROT to allow LLS power modes this write-once 
    326          //      bit allows the MCU to enter the LLS low power mode*/
    327          //   SMC_PMPROT = SMC_PMPROT_ALLS_MASK;   
    328          //   /* Set the STOPM field to 0b011 for LLS mode  */
    329          //   SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK; 
    330          //   SMC_PMCTRL |=  SMC_PMCTRL_STOPM(0x3); 
    331          //   /*wait for write to complete to SMC before stopping core */  
    332          //   dummyread = SMC_PMCTRL;
    333          //   dummyread++;
    334          //   /* Now execute the stop instruction to go into LLS */
    335          //   #ifdef CMSIS
    336          //   /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
    337          //   SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
    338          //   __wfi();
    339          // #else
    340          //   stop();
    341          // #endif
    342          // }
    343          /***************************************************************/
    344          /* VLLS3 mode entry routine. Puts the processor into 
    345           * VLLS3 mode from normal run mode or VLPR. 
    346           *
    347           * Mode transitions:
    348           * RUN -> VLLS3
    349           * VLPR -> VLLS3
    350           *
    351           * NOTE: VLLSx modes will always exit to RUN mode even if you were 
    352           * in VLPR mode before entering VLLSx.
    353           *
    354           * Wakeup from VLLSx mode is controlled by the LLWU module. Most
    355           * modules cannot issue a wakeup interrupt in VLLSx mode, so make
    356           * sure to setup the desired wakeup sources in the LLWU before 
    357           * calling this function.
    358           *
    359           * Parameters:
    360           * none  
    361           */
    362           /********************************************************************/
    363          

   \                                 In section .text, align 2, keep-with-next
    364          void enter_vlls3(void)
    365          {
   \                     enter_vlls3: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    366            volatile unsigned int dummyread;
    367            /* Write to PMPROT to allow VLLS3 power modes */
    368            SMC_PMPROT = SMC_PMPROT_AVLLS_MASK;      
   \   00000002   0x2002             MOVS     R0,#+2
   \   00000004   0x....             LDR      R1,??DataTable9  ;; 0x4007e000
   \   00000006   0x7008             STRB     R0,[R1, #+0]
    369            /* Set the STOPM field to 0b100 for VLLS3 mode */
    370            SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK; 
   \   00000008   0x....             LDR      R0,??DataTable10_1  ;; 0x4007e001
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x21F8             MOVS     R1,#+248
   \   0000000E   0x4001             ANDS     R1,R1,R0
   \   00000010   0x....             LDR      R0,??DataTable10_1  ;; 0x4007e001
   \   00000012   0x7001             STRB     R1,[R0, #+0]
    371            SMC_PMCTRL |=  SMC_PMCTRL_STOPM(0x4); 
   \   00000014   0x....             LDR      R0,??DataTable10_1  ;; 0x4007e001
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x2104             MOVS     R1,#+4
   \   0000001A   0x4301             ORRS     R1,R1,R0
   \   0000001C   0x....             LDR      R0,??DataTable10_1  ;; 0x4007e001
   \   0000001E   0x7001             STRB     R1,[R0, #+0]
    372            /* set VLLSM = 0b11 */
    373            SMC_STOPCTRL =  SMC_STOPCTRL_VLLSM(3);          
   \   00000020   0x2003             MOVS     R0,#+3
   \   00000022   0x....             LDR      R1,??DataTable9_1  ;; 0x4007e002
   \   00000024   0x7008             STRB     R0,[R1, #+0]
    374            /*wait for write to complete to SMC before stopping core */  
    375            dummyread = SMC_STOPCTRL;
   \   00000026   0x....             LDR      R0,??DataTable9_1  ;; 0x4007e002
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0xB2C0             UXTB     R0,R0
   \   0000002C   0x9000             STR      R0,[SP, #+0]
    376            dummyread++;
   \   0000002E   0x9800             LDR      R0,[SP, #+0]
   \   00000030   0x1C40             ADDS     R0,R0,#+1
   \   00000032   0x9000             STR      R0,[SP, #+0]
    377            /* Now execute the stop instruction to go into VLLS3 */
    378            #ifdef CMSIS
    379            /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
    380            SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
    381            __wfi();
    382          #else
    383            stop();
   \   00000034   0x.... 0x....      BL       stop
    384          #endif
    385          }
   \   00000038   0xBD01             POP      {R0,PC}          ;; return
    386          /***************************************************************/
    387          /* VLLS2 mode entry routine. Puts the processor into 
    388           * VLLS2 mode from normal run mode or VLPR. 
    389           *
    390           * Mode transitions:
    391           * RUN -> VLLS2
    392           * VLPR -> VLLS2
    393           *
    394           * NOTE: VLLSx modes will always exit to RUN mode even  
    395           *       if you werein VLPR mode before entering VLLSx.
    396           *
    397           * Wakeup from VLLSx mode is controlled by the LLWU module. Most
    398           * modules cannot issue a wakeup interrupt in VLLSx mode, so make
    399           * sure to setup the desired wakeup sources in the LLWU before 
    400           * calling this function.
    401           *
    402           * Parameters:
    403           * none  
    404           */
    405           /********************************************************************/
    406          

   \                                 In section .text, align 2, keep-with-next
    407          void enter_vlls2(void)
    408          {
   \                     enter_vlls2: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    409            volatile unsigned int dummyread;
    410            /* Write to PMPROT to allow VLLS2 power modes */
    411            SMC_PMPROT = SMC_PMPROT_AVLLS_MASK;      
   \   00000002   0x2002             MOVS     R0,#+2
   \   00000004   0x....             LDR      R1,??DataTable9  ;; 0x4007e000
   \   00000006   0x7008             STRB     R0,[R1, #+0]
    412            /* Set the STOPM field to 0b100 for VLLS2 mode */
    413            SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK; 
   \   00000008   0x....             LDR      R0,??DataTable10_1  ;; 0x4007e001
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x21F8             MOVS     R1,#+248
   \   0000000E   0x4001             ANDS     R1,R1,R0
   \   00000010   0x....             LDR      R0,??DataTable10_1  ;; 0x4007e001
   \   00000012   0x7001             STRB     R1,[R0, #+0]
    414            SMC_PMCTRL |=  SMC_PMCTRL_STOPM(0x4); 
   \   00000014   0x....             LDR      R0,??DataTable10_1  ;; 0x4007e001
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x2104             MOVS     R1,#+4
   \   0000001A   0x4301             ORRS     R1,R1,R0
   \   0000001C   0x....             LDR      R0,??DataTable10_1  ;; 0x4007e001
   \   0000001E   0x7001             STRB     R1,[R0, #+0]
    415            /* set VLLSM = 0b10 */
    416            SMC_STOPCTRL =  SMC_STOPCTRL_VLLSM(2);                
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0x....             LDR      R1,??DataTable9_1  ;; 0x4007e002
   \   00000024   0x7008             STRB     R0,[R1, #+0]
    417            /*wait for write to complete to SMC before stopping core */  
    418            dummyread = SMC_STOPCTRL;
   \   00000026   0x....             LDR      R0,??DataTable9_1  ;; 0x4007e002
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0xB2C0             UXTB     R0,R0
   \   0000002C   0x9000             STR      R0,[SP, #+0]
    419            dummyread++;
   \   0000002E   0x9800             LDR      R0,[SP, #+0]
   \   00000030   0x1C40             ADDS     R0,R0,#+1
   \   00000032   0x9000             STR      R0,[SP, #+0]
    420            /* Now execute the stop instruction to go into VLLS2 */
    421            #ifdef CMSIS
    422            /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
    423            SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
    424            __wfi();
    425          #else
    426            stop();
   \   00000034   0x.... 0x....      BL       stop
    427          #endif
    428          }
   \   00000038   0xBD01             POP      {R0,PC}          ;; return
    429          /***************************************************************/
    430          /* VLLS1 mode entry routine. Puts the processor into 
    431           * VLLS1 mode from normal run mode or VLPR. 
    432           *
    433           * Mode transitions:
    434           * RUN -> VLLS1
    435           * VLPR -> VLLS1
    436           *
    437           * NOTE: VLLSx modes will always exit to RUN mode even if you were 
    438           * in VLPR mode before entering VLLSx.
    439           *
    440           * Wakeup from VLLSx mode is controlled by the LLWU module. Most
    441           * modules cannot issue a wakeup interrupt in VLLSx mode, so make
    442           * sure to setup the desired wakeup sources in the LLWU before 
    443           * calling this function.
    444           *
    445           * Parameters:
    446           * none  
    447           */
    448           /********************************************************************/
    449          

   \                                 In section .text, align 2, keep-with-next
    450          void enter_vlls1(void)
    451          {
   \                     enter_vlls1: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    452            volatile unsigned int dummyread;
    453            SMC_PMPROT = SMC_PMPROT_AVLLS_MASK;
   \   00000002   0x2002             MOVS     R0,#+2
   \   00000004   0x....             LDR      R1,??DataTable9  ;; 0x4007e000
   \   00000006   0x7008             STRB     R0,[R1, #+0]
    454              
    455            /* Write to PMPROT to allow all possible power modes */
    456            /* Set the STOPM field to 0b100 for VLLS1 mode */
    457            SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK; 
   \   00000008   0x....             LDR      R0,??DataTable10_1  ;; 0x4007e001
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x21F8             MOVS     R1,#+248
   \   0000000E   0x4001             ANDS     R1,R1,R0
   \   00000010   0x....             LDR      R0,??DataTable10_1  ;; 0x4007e001
   \   00000012   0x7001             STRB     R1,[R0, #+0]
    458            SMC_PMCTRL |=  SMC_PMCTRL_STOPM(0x4); 
   \   00000014   0x....             LDR      R0,??DataTable10_1  ;; 0x4007e001
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x2104             MOVS     R1,#+4
   \   0000001A   0x4301             ORRS     R1,R1,R0
   \   0000001C   0x....             LDR      R0,??DataTable10_1  ;; 0x4007e001
   \   0000001E   0x7001             STRB     R1,[R0, #+0]
    459            /* set VLLSM = 0b01 */
    460            SMC_STOPCTRL =  SMC_STOPCTRL_VLLSM(1);          
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x....             LDR      R1,??DataTable9_1  ;; 0x4007e002
   \   00000024   0x7008             STRB     R0,[R1, #+0]
    461            /*wait for write to complete to SMC before stopping core */  
    462            dummyread = SMC_STOPCTRL;
   \   00000026   0x....             LDR      R0,??DataTable9_1  ;; 0x4007e002
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0xB2C0             UXTB     R0,R0
   \   0000002C   0x9000             STR      R0,[SP, #+0]
    463            dummyread++;
   \   0000002E   0x9800             LDR      R0,[SP, #+0]
   \   00000030   0x1C40             ADDS     R0,R0,#+1
   \   00000032   0x9000             STR      R0,[SP, #+0]
    464            /* Now execute the stop instruction to go into VLLS1 */
    465            #ifdef CMSIS
    466            /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
    467            SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
    468            __wfi();
    469          #else
    470            stop();
   \   00000034   0x.... 0x....      BL       stop
    471          #endif
    472          }
   \   00000038   0xBD01             POP      {R0,PC}          ;; return
    473          
    474          /********************************************************************/
    475          /* VLLS0 mode entry routine. Puts the processor into VLLS0 mode from
    476           * normal run mode or VLPR. 
    477           *
    478           * Mode transitions:
    479           * RUN -> VLLS0
    480           * VLPR -> VLLS0
    481           *
    482           * NOTE: VLLSx modes will always exit to RUN mode even if you were 
    483           * in VLPR mode before entering VLLSx.
    484           *
    485           * Wakeup from VLLSx mode is controlled by the LLWU module. Most
    486           * modules cannot issue a wakeup interrupt in VLLSx mode, so make
    487           * sure to setup the desired wakeup sources in the LLWU before 
    488           * calling this function.
    489           *
    490           * Parameters:
    491           * PORPO_value - 0 POR detect circuit is enabled in VLLS0
    492           *               1 POR detect circuit is disabled in VLLS0
    493           */
    494           /***************************************************************/
    495          

   \                                 In section .text, align 2, keep-with-next
    496          void enter_vlls0(unsigned char PORPO_value )
    497          {
   \                     enter_vlls0: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    498            int i;
    499            /* Write to PMPROT to allow all possible power modes */
    500            SMC_PMPROT = SMC_PMPROT_AVLLS_MASK;   
   \   00000002   0x2102             MOVS     R1,#+2
   \   00000004   0x....             LDR      R2,??DataTable9  ;; 0x4007e000
   \   00000006   0x7011             STRB     R1,[R2, #+0]
    501            if ((SMC_PMSTAT & SMC_PMSTAT_PMSTAT_MASK)== 4){
   \   00000008   0x....             LDR      R1,??DataTable10_2  ;; 0x4007e003
   \   0000000A   0x7809             LDRB     R1,[R1, #+0]
   \   0000000C   0xB2C9             UXTB     R1,R1
   \   0000000E   0x0649             LSLS     R1,R1,#+25       ;; ZeroExtS R1,R1,#+25,#+25
   \   00000010   0x0E49             LSRS     R1,R1,#+25
   \   00000012   0x2904             CMP      R1,#+4
   \   00000014   0xD111             BNE      ??enter_vlls0_0
    502               SMC_PMCTRL &= ~SMC_PMCTRL_RUNM_MASK;   // go back to RUN mode temporarily
   \   00000016   0x....             LDR      R1,??DataTable10_1  ;; 0x4007e001
   \   00000018   0x7809             LDRB     R1,[R1, #+0]
   \   0000001A   0x229F             MOVS     R2,#+159
   \   0000001C   0x400A             ANDS     R2,R2,R1
   \   0000001E   0x....             LDR      R1,??DataTable10_1  ;; 0x4007e001
   \   00000020   0x700A             STRB     R2,[R1, #+0]
    503               for (i=0;i<0xff;i++)
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0xE000             B        ??enter_vlls0_1
   \                     ??enter_vlls0_2: (+1)
   \   00000026   0x1C49             ADDS     R1,R1,#+1
   \                     ??enter_vlls0_1: (+1)
   \   00000028   0x29FF             CMP      R1,#+255
   \   0000002A   0xDA06             BGE      ??enter_vlls0_0
    504                 {
    505                 if ((SMC_PMSTAT & SMC_PMSTAT_PMSTAT_MASK)== 1)
   \   0000002C   0x....             LDR      R2,??DataTable10_2  ;; 0x4007e003
   \   0000002E   0x7812             LDRB     R2,[R2, #+0]
   \   00000030   0xB2D2             UXTB     R2,R2
   \   00000032   0x0652             LSLS     R2,R2,#+25       ;; ZeroExtS R2,R2,#+25,#+25
   \   00000034   0x0E52             LSRS     R2,R2,#+25
   \   00000036   0x2A01             CMP      R2,#+1
   \   00000038   0xD1F5             BNE      ??enter_vlls0_2
    506              	 break;
    507                 }
    508            }
    509            /* Set the STOPM field to 0b100 for VLLS0 mode */
    510            SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK; 
   \                     ??enter_vlls0_0: (+1)
   \   0000003A   0x....             LDR      R1,??DataTable10_1  ;; 0x4007e001
   \   0000003C   0x7809             LDRB     R1,[R1, #+0]
   \   0000003E   0x22F8             MOVS     R2,#+248
   \   00000040   0x400A             ANDS     R2,R2,R1
   \   00000042   0x....             LDR      R1,??DataTable10_1  ;; 0x4007e001
   \   00000044   0x700A             STRB     R2,[R1, #+0]
    511            SMC_PMCTRL |=  SMC_PMCTRL_STOPM(0x4); 
   \   00000046   0x....             LDR      R1,??DataTable10_1  ;; 0x4007e001
   \   00000048   0x7809             LDRB     R1,[R1, #+0]
   \   0000004A   0x2204             MOVS     R2,#+4
   \   0000004C   0x430A             ORRS     R2,R2,R1
   \   0000004E   0x....             LDR      R1,??DataTable10_1  ;; 0x4007e001
   \   00000050   0x700A             STRB     R2,[R1, #+0]
    512            /* set VLLSM = 0b00 */
    513            SMC_STOPCTRL &= ~SMC_STOPCTRL_VLLSM_MASK;
   \   00000052   0x....             LDR      R1,??DataTable9_1  ;; 0x4007e002
   \   00000054   0x7809             LDRB     R1,[R1, #+0]
   \   00000056   0x22F8             MOVS     R2,#+248
   \   00000058   0x400A             ANDS     R2,R2,R1
   \   0000005A   0x....             LDR      R1,??DataTable9_1  ;; 0x4007e002
   \   0000005C   0x700A             STRB     R2,[R1, #+0]
    514            SMC_STOPCTRL &= ~SMC_STOPCTRL_PORPO_MASK;
   \   0000005E   0x....             LDR      R1,??DataTable9_1  ;; 0x4007e002
   \   00000060   0x7809             LDRB     R1,[R1, #+0]
   \   00000062   0x22DF             MOVS     R2,#+223
   \   00000064   0x400A             ANDS     R2,R2,R1
   \   00000066   0x....             LDR      R1,??DataTable9_1  ;; 0x4007e002
   \   00000068   0x700A             STRB     R2,[R1, #+0]
    515            SMC_STOPCTRL |=  (PORPO_value <<SMC_STOPCTRL_PORPO_SHIFT) 
    516                           | SMC_STOPCTRL_VLLSM(0);          
   \   0000006A   0x....             LDR      R1,??DataTable9_1  ;; 0x4007e002
   \   0000006C   0x7809             LDRB     R1,[R1, #+0]
   \   0000006E   0xB2C0             UXTB     R0,R0
   \   00000070   0x0140             LSLS     R0,R0,#+5
   \   00000072   0x4308             ORRS     R0,R0,R1
   \   00000074   0x....             LDR      R1,??DataTable9_1  ;; 0x4007e002
   \   00000076   0x7008             STRB     R0,[R1, #+0]
    517            /*wait for write to complete to SMC before stopping core */  
    518            PORPO_value = SMC_STOPCTRL;
   \   00000078   0x....             LDR      R0,??DataTable9_1  ;; 0x4007e002
   \   0000007A   0x7800             LDRB     R0,[R0, #+0]
    519            /* Now execute the stop instruction to go into VLLS0 */
    520            #ifdef CMSIS
    521            /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
    522            SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
    523            __wfi();
    524          #else
    525            stop();
   \   0000007C   0x.... 0x....      BL       stop
    526          #endif
    527          }
   \   00000080   0xBD01             POP      {R0,PC}          ;; return
    528          /***************************************************************/
    529          /* VLLS0 mode entry routine. Puts the processor into VLLS0 mode from
    530           * normal run mode or VLPR with the POR circuit disabled
    531           *
    532           * Mode transitions:
    533           * RUN -> VLLS0
    534           * VLPR -> VLLS0
    535           *
    536           * NOTE: VLLSx modes will always exit to RUN mode even if you were 
    537           * in VLPR mode before entering VLLSx.
    538           *
    539           * Wakeup from VLLSx mode is controlled by the LLWU module. Most
    540           * modules cannot issue a wakeup interrupt in VLLSx mode, so make
    541           * sure to setup the desired wakeup sources in the LLWU before 
    542           * calling this function.
    543           *
    544           * Parameters:
    545           * PORPO = 1-  POR detect circuit is disabled in VLLS0
    546           */
    547          /***************************************************************/

   \                                 In section .text, align 2, keep-with-next
    548          void enter_vlls0_nopor(void)
    549          {
   \                     enter_vlls0_nopor: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    550            volatile unsigned int dummyread;
    551            int i;
    552            /* Write to PMPROT to allow all possible power modes */
    553            SMC_PMPROT = SMC_PMPROT_AVLLS_MASK;   
   \   00000002   0x2002             MOVS     R0,#+2
   \   00000004   0x....             LDR      R1,??DataTable10_5  ;; 0x4007e000
   \   00000006   0x7008             STRB     R0,[R1, #+0]
    554            if ((SMC_PMSTAT & SMC_PMSTAT_PMSTAT_MASK)== 4){
   \   00000008   0x....             LDR      R0,??DataTable10_2  ;; 0x4007e003
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0xB2C0             UXTB     R0,R0
   \   0000000E   0x0640             LSLS     R0,R0,#+25       ;; ZeroExtS R0,R0,#+25,#+25
   \   00000010   0x0E40             LSRS     R0,R0,#+25
   \   00000012   0x2804             CMP      R0,#+4
   \   00000014   0xD111             BNE      ??enter_vlls0_nopor_0
    555               SMC_PMCTRL &= ~SMC_PMCTRL_RUNM_MASK;   // go back to RUN mode temporarily
   \   00000016   0x....             LDR      R0,??DataTable10_1  ;; 0x4007e001
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x219F             MOVS     R1,#+159
   \   0000001C   0x4001             ANDS     R1,R1,R0
   \   0000001E   0x....             LDR      R0,??DataTable10_1  ;; 0x4007e001
   \   00000020   0x7001             STRB     R1,[R0, #+0]
    556               for (i=0;i<0xff;i++)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE000             B        ??enter_vlls0_nopor_1
   \                     ??enter_vlls0_nopor_2: (+1)
   \   00000026   0x1C40             ADDS     R0,R0,#+1
   \                     ??enter_vlls0_nopor_1: (+1)
   \   00000028   0x28FF             CMP      R0,#+255
   \   0000002A   0xDA06             BGE      ??enter_vlls0_nopor_0
    557                 {
    558                 if ((SMC_PMSTAT & SMC_PMSTAT_PMSTAT_MASK)== 1)
   \   0000002C   0x....             LDR      R1,??DataTable10_2  ;; 0x4007e003
   \   0000002E   0x7809             LDRB     R1,[R1, #+0]
   \   00000030   0xB2C9             UXTB     R1,R1
   \   00000032   0x0649             LSLS     R1,R1,#+25       ;; ZeroExtS R1,R1,#+25,#+25
   \   00000034   0x0E49             LSRS     R1,R1,#+25
   \   00000036   0x2901             CMP      R1,#+1
   \   00000038   0xD1F5             BNE      ??enter_vlls0_nopor_2
    559              	 break;
    560                 }
    561            }
    562            /* Set the STOPM field to 0b100 for VLLS0 mode */
    563            SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK; 
   \                     ??enter_vlls0_nopor_0: (+1)
   \   0000003A   0x....             LDR      R0,??DataTable10_1  ;; 0x4007e001
   \   0000003C   0x7800             LDRB     R0,[R0, #+0]
   \   0000003E   0x21F8             MOVS     R1,#+248
   \   00000040   0x4001             ANDS     R1,R1,R0
   \   00000042   0x....             LDR      R0,??DataTable10_1  ;; 0x4007e001
   \   00000044   0x7001             STRB     R1,[R0, #+0]
    564            SMC_PMCTRL |=  SMC_PMCTRL_STOPM(0x4); 
   \   00000046   0x....             LDR      R0,??DataTable10_1  ;; 0x4007e001
   \   00000048   0x7800             LDRB     R0,[R0, #+0]
   \   0000004A   0x2104             MOVS     R1,#+4
   \   0000004C   0x4301             ORRS     R1,R1,R0
   \   0000004E   0x....             LDR      R0,??DataTable10_1  ;; 0x4007e001
   \   00000050   0x7001             STRB     R1,[R0, #+0]
    565            /* set VLLSM = 00 * and PORPO = 1 */
    566            SMC_STOPCTRL &= ~SMC_STOPCTRL_VLLSM_MASK;
   \   00000052   0x....             LDR      R0,??DataTable10_6  ;; 0x4007e002
   \   00000054   0x7800             LDRB     R0,[R0, #+0]
   \   00000056   0x21F8             MOVS     R1,#+248
   \   00000058   0x4001             ANDS     R1,R1,R0
   \   0000005A   0x....             LDR      R0,??DataTable10_6  ;; 0x4007e002
   \   0000005C   0x7001             STRB     R1,[R0, #+0]
    567            SMC_STOPCTRL =  SMC_STOPCTRL_VLLSM(0) | SMC_STOPCTRL_PORPO_MASK;  
   \   0000005E   0x2020             MOVS     R0,#+32
   \   00000060   0x....             LDR      R1,??DataTable10_6  ;; 0x4007e002
   \   00000062   0x7008             STRB     R0,[R1, #+0]
    568            /*wait for write to complete to SMC before stopping core */  
    569            dummyread = SMC_STOPCTRL;
   \   00000064   0x....             LDR      R0,??DataTable10_6  ;; 0x4007e002
   \   00000066   0x7800             LDRB     R0,[R0, #+0]
   \   00000068   0xB2C0             UXTB     R0,R0
   \   0000006A   0x9000             STR      R0,[SP, #+0]
    570            dummyread++;
   \   0000006C   0x9800             LDR      R0,[SP, #+0]
   \   0000006E   0x1C40             ADDS     R0,R0,#+1
   \   00000070   0x9000             STR      R0,[SP, #+0]
    571            /* Now execute the stop instruction to go into VLLS0 */
    572            #ifdef CMSIS
    573            /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
    574            SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
    575            __wfi();
    576          #else
    577            stop();
   \   00000072   0x.... 0x....      BL       stop
    578          #endif
    579          }
   \   00000076   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x4007E000         DC32     0x4007e000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x4007E002         DC32     0x4007e002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0xE000ED10         DC32     0xe000ed10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x4007E001         DC32     0x4007e001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x4007E003         DC32     0x4007e003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x00002710         DC32     0x2710

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x4007D002         DC32     0x4007d002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x4007E000         DC32     0x4007e000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x4007E002         DC32     0x4007e002
    580          
    581          
    582          /********************************************************************/
    583          /********************End of Functions *******************************/
    584          /********************************************************************/
    585          
    586          
    587          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   deepsleep
       8   enter_stop
         8   -> stop
       8   enter_vlls0
         8   -> stop
       8   enter_vlls0_nopor
         8   -> stop
       8   enter_vlls1
         8   -> stop
       8   enter_vlls2
         8   -> stop
       8   enter_vlls3
         8   -> stop
       4   enter_vlpr
       8   enter_vlps
         8   -> stop
       8   enter_wait
         8   -> wait
       4   exit_vlpr
       0   sleep


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable9
       4  ??DataTable9_1
      16  deepsleep
      60  enter_stop
     130  enter_vlls0
     120  enter_vlls0_nopor
      58  enter_vlls1
      58  enter_vlls2
      58  enter_vlls3
     104  enter_vlpr
      52  enter_vlps
       8  enter_wait
      58  exit_vlpr
      16  sleep

 
 774 bytes in section .text
 
 774 bytes of CODE memory

Errors: none
Warnings: 1
